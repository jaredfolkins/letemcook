# Let ’Em Cook (LEMC) Architecture and Workflow

**Let ’Em Cook (LEMC)** is an open-source system for automating predefined “recipes” (scripts) by running them in containerized steps on demand or on a schedule, with live results streamed to a web interface. It “Ops your Devs” by letting developers package operational tasks as Docker container images and execute them through a friendly UI. Below, we break down LEMC’s architecture, runtime behavior, host interactions, and how users configure/invoke it, with diagrams to illustrate each aspect.

## Overall Architecture of LEMC

&#x20;*Figure: LEMC overall architecture and component interaction.* LEMC’s core is a Go-based server (code-named **YesChef**) that exposes a web UI and orchestrates the execution of recipes. Users interact with LEMC through a browser-based **Web UI** (built with HTMX and Templ) served by the backend. The backend persists data (users, cookbooks, recipes, logs, etc.) in a **SQLite database**, and it leverages the host’s **Docker Daemon** (via Docker’s API socket) to run recipe steps in isolated containers. Each **recipe** consists of one or more **steps**, where each step is a script packaged as a Docker image (containing all its code and dependencies). LEMC is language-agnostic – any language or tool can be used inside steps as long as it can run in a container and print output. A **container registry** (like Docker Hub or a private registry) is used to store and distribute these step images; LEMC will pull the needed image if it’s not already available locally. The web UI and backend communicate in real-time (over WebSockets) so that as containers produce output, the results are immediately pushed to the user’s browser. In essence, the architecture links the **user interface**, the **LEMC server**, the **database**, and **Docker** as an execution sandbox, enabling on-demand automation of tasks.

Key components in this architecture include:

* **Cookbooks and Recipes:** In LEMC, recipes (tasks) are organized into *cookbooks*. A cookbook is a collection of related recipes, and each recipe is defined by one or more step containers to run. The LEMC server stores these definitions in the SQLite DB and presents them in the UI as buttons or actions. Recipes can be executed on demand (by user click) or scheduled to run periodically.
* **YesChef Backend (LEMC Server):** The backend is a Go application (using the Echo framework) that provides a web server and manages job execution. It handles user authentication (an admin account is created on first launch, and additional users can be managed), serves the HTML interface, and implements a WebSocket channel to stream output to the UI. It uses Gorilla WebSocket for real-time updates. The backend also includes a scheduler component (based on go-quartz) to support cron-like scheduling of recipes.
* **Web UI:** LEMC’s front-end is delivered via server-side rendered pages (Templ templates) enhanced with HTMX for dynamic behavior. Users access the UI through a browser. The UI lists available Apps/Cookbooks and their recipes. When a recipe runs, the UI displays live output (text or HTML) streaming from the container. Special LEMC output commands (discussed below) allow rich content like formatted HTML, CSS, or JavaScript to be displayed in the browser in real time.
* **Docker Containers (Recipe Steps):** Each recipe step runs inside a Docker container launched by LEMC. This containerization provides isolation and consistency across environments. For example, one step might be a Python script in a Python image, and the next step could be a Bash script in an Alpine Linux image – LEMC handles running each in the appropriate container, passing data between steps as needed. Docker ensures that each step’s code runs with its required dependencies and does not affect the host system directly (aside from controlled interactions like volume mounts). LEMC relies on Docker’s sandboxing as a primary security mechanism.
* **Persistent Storage:** LEMC uses a local `data/` directory (on the host or container running LEMC) to store its SQLite database and configuration (it auto-initializes this on first run). This storage retains all cookbook definitions, user accounts, execution history, etc., across restarts.

In the architecture diagram above, the **User** triggers a recipe via the browser, causing the **LEMC Server** to retrieve the recipe definition from **SQLite DB**, then instruct the **Docker Daemon** to run the specified container image for each step. If the image isn’t present, Docker will pull it from the **Container Registry** first. As the container runs, the script’s output (stdout) is monitored by the backend; special **LEMC Verbs** printed in the output are intercepted for UI updates or state passing (instead of being shown raw). The backend streams live feedback to the user’s browser (via WebSocket or server-sent events) so the user can see progress. Multiple steps are executed in sequence (each as a fresh container) – after one step finishes, the next container is started, potentially using environment data passed along. The **Scheduler** can also trigger the backend to start a recipe at predetermined times (dotted line in the diagram). Throughout execution, any files that the script writes to a special shared volume (e.g. `/lemc/public`) will be accessible to the LEMC server for download links (this is shown as the **Bind-Mounted Volume** for outputs) – for example, a script can drop a report file which the UI can present as a downloadable link.

## Runtime Behavior and Lifecycle of a Recipe Execution

LEMC’s runtime behavior follows a clear sequence of events from the moment a recipe is invoked to the completion of all its steps. The system manages the lifecycle of each “job” (recipe run) and maintains state between steps as needed. The diagram below illustrates the typical flow of execution for a recipe:

&#x20;*Figure: LEMC recipe execution flow (lifecycle of a run).* When a recipe is **triggered** – either by a user clicking its run button in the UI, or by an automated schedule – the LEMC backend creates a new job and begins executing the recipe’s steps. If the recipe has multiple steps, they will run **sequentially** (one container after another). The execution lifecycle can be described in stages:

1. **Trigger Phase:** A recipe run can start via manual or scheduled trigger. In a manual case, a user selects an App/page in the web UI and clicks on a recipe’s button to run it, which sends an HTTP request to the server to start the job. In a scheduled case, the built-in scheduler (go-quartz) will automatically initiate the job at the configured time (as if a “virtual click” happened). In both cases, the backend transitions from an idle state to a “recipe running” state for that job.
2. **Container Launch (Step 1):** The backend looks up the first step of the recipe to determine which Docker image to use and any parameters (like a timeout or input values). It then instructs the Docker daemon to launch a new container for this step. LEMC automatically injects several **environment variables** into the container before it starts – these include context like the step number, the user who triggered it, the recipe name, and a unique job ID, among others. This provides the script with context and a channel to communicate results (for example, knowing `LEMC_HTML_ID` or base URLs for output files). If this is the first step of a recipe, environment variables may include defaults or initial context; if it’s a subsequent step, it will also include any variables set by previous steps (explained below). The Docker container then executes the script (the container’s `CMD` runs the script file).
3. **Live Execution and Output Streaming:** As the script inside the container runs, it typically prints output to standard output (stdout). The LEMC backend attaches to the container’s output stream (using Docker APIs) and **parses each line** in real-time. **Normal output lines** (without the special prefix) can be forwarded directly to the UI (often as plain text or log output), while lines beginning with `lemc.` are treated as **LEMC commands**:

    * `lemc.html.buffer; ...`, `lemc.html.append;` – these tell LEMC to collect HTML fragments and then append them to the web UI. This allows scripts to build rich HTML output (tables, formatted text, etc.) that appears in the user’s browser.
    * `lemc.css.append; ...` or `lemc.css.trunc; ...` – similar for injecting CSS styles into the page.
    * `lemc.js.exec; ...` – for executing JavaScript in the client (if needed for interactive results).
    * `lemc.env;KEY=value` – this is critical for multi-step recipes: it tells LEMC to set an environment variable `KEY=value` that will persist into the **next step’s** container environment. This is how one step can pass data to subsequent steps.

   The YesChef backend processes these verbs on the fly. For example, if a script prints `lemc.env;STATUS=ok`, the backend will record that `STATUS` should be exported in the environment for the next container before it starts. If the script prints `lemc.html.buffer;<p>Hello</p>`, the backend buffers that HTML snippet and, upon receiving a corresponding `lemc.html.append;` or end-of-step, pushes it to the UI to be rendered. Throughout the step’s execution, LEMC streams output and updates to the user’s browser **in real time**. The UI will update live, showing text logs or rendered HTML content as directed by the script. This is achieved via a WebSocket connection: the backend sends messages to the front-end whenever there’s new output (or uses HTMX triggers for partial updates).
4. **Step Completion and Transition:** When the script in the container finishes (the process exits), Docker reports the container’s exit status to the LEMC backend. LEMC marks this step as completed (and may log the outcome). If the recipe has another step, the system proceeds to launch the **next container**:

    * Before launching the next step, LEMC prepares its environment. All the `lemc.env` variables that were collected from the previous step’s output are now injected into the next container’s env, so the next script can directly use those values. This mechanism allows state to carry over (for example, Step 1 might produce an API token or compute a value that Step 2 needs).
    * The Docker daemon is then instructed to run the next step’s image, just like before. LEMC ensures (again) that the correct image version is present (pulling from the registry if needed, which typically would have been done upfront on first use).
    * The output of Step 2 is streamed in the same fashion, and any further `lemc.env` from step 2 would go to step 3, and so on.
5. **Recipe Completion:** This loop continues until all defined steps in the recipe have been executed. At that point, the backend marks the entire recipe run as **completed**. Final status (success/failure per step) is recorded, and the UI may display a “completed” message or enable any post-run options (like downloading files). All the live output that was streamed remains visible in the UI, typically appended in the recipe’s output panel for the user to review. If the recipe was triggered manually, the user sees the result immediately; if it was scheduled and ran in the background, a user can likely view the output/logs after the fact by accessing the App and recipe page.
6. **Result Persistence:** By default, anything printed to the UI (via LEMC verbs or plain output) is captured for the session but not permanently stored in the UI after reload (though logs may be stored in the DB or files). However, if a script needs to deliver a file or artifact, it can place it in the shared **output volume**. LEMC mounts a host directory into each container at a path (like `/lemc/public/`), and any file dropped there will be accessible via an HTTP URL. For instance, a script might create `/lemc/public/report.pdf`; the backend serves this file through a special download route (with a URL containing the cookbook UUID, page, scope, and filename). The user can then download it from the UI. This mechanism enables passing larger results or files out of the container sandbox in a controlled way.

Throughout the runtime, LEMC manages the **state** of the job: it knows which step is currently running and what environment context has been accumulated. If an error occurs (e.g., a container exits with a non-zero status), LEMC would typically stop the remaining steps (unless configured otherwise) and mark the job as failed, presenting the error in the UI. The isolation provided by Docker means that each step’s execution environment is fresh – once a container exits, any filesystem changes inside it (aside from the mounted output folder) are discarded, preventing side effects on subsequent runs. This ensures consistent behavior run-to-run, and if a recipe needs to maintain state across runs, it would do so via external systems or by writing to the mounted volume or database explicitly.

## Interactions with the Host System and External Tools

While most of LEMC’s logic operates at an application level, it interacts with the host operating system and external services in several important ways, as shown in the architecture. Key host/external interactions include:

* **Docker Daemon (Containers on Host):** LEMC requires access to a Docker service on the host machine to run recipe steps. In a typical installation, the LEMC backend has the Docker UNIX socket (`/var/run/docker.sock`) mounted or accessible. By sending commands to this socket (using Docker’s Go SDK or HTTP API), LEMC asks the host’s Docker daemon to perform actions like pulling images, creating containers, starting/stopping containers, and attaching to container logs. This means the LEMC process itself doesn’t spawn system processes directly for user scripts – it delegates to Docker, which in turn creates isolated container processes on the host OS. The benefit is that the actual script execution is confined within Docker’s control (namespaces, cgroups, etc.), offering a layer of isolation from the host. The trade-off is that LEMC inherently trusts the Docker daemon; access to the Docker socket is a powerful capability (effectively root-equivalent on the host), so LEMC is designed for environments where authorized users are trusted or Docker is properly sandboxed. **Security:** Docker acts as the sandbox. LEMC’s documentation notes that it “relies on Docker container isolation as the primary sandboxing mechanism”. It doesn’t run untrusted code directly on the host – only inside containers. Thus, host security is largely delegated to Docker’s security model. Administrators should control who can define or execute recipes, since those users ultimately run code on the host via Docker.
* **File System and Volume Mounts:** The LEMC server itself uses the host file system to store its data. On first run, LEMC initializes a `data/` directory (in the working directory or a configured path), creates a SQLite database file, and also generates a `.env` file with default configs. All user-created content like cookbook definitions, user accounts, and job logs are stored in the database or in this directory. Additionally, as described, LEMC sets up a **bind mount** into each container for output files. By default, a directory (often under `data/` or a subpath like `data/public/`) is mounted into the container at `/lemc/public`. This allows two-way file exchange: the container can write files that the host (and LEMC server) can read, and theoretically the server could also provide input files via this mount. After execution, any files left in that folder are served by the LEMC backend through an HTTP endpoint (the `LEMC_HTTP_DOWNLOAD_BASE_URL` env variable gives the route structure). This mechanism is the primary means for a container to have side effects on the host (writing output files). Aside from this mounted folder and the Docker socket, containers are not given arbitrary host access – they run with whatever filesystem is in their image plus the mount. The LEMC process itself may also write logs to files or stdout for its own logging, but operationally most data is in the SQLite DB.
* **Networking and Registry Access:** To fetch container images, the Docker daemon may reach out to external container registries. For example, if a recipe’s Docker image is `dockerhub.com/myrepo/tool:latest` and it’s not already cached, Docker will perform an image pull from the internet. LEMC facilitates this by naming the image and letting Docker handle the download. In the Quick Start example, an image `lemc-my-first-recipe:latest` is built locally, but for sharing, users are encouraged to push images to a registry and then reference them by name. Thus, one external interaction is **Docker Hub/Registry** access. LEMC itself doesn’t directly contact the registry; it relies on Docker to do so when needed. In terms of other network interactions: the LEMC web server listens on a port (default `5362`) for user connections, and it upgrades some connections to WebSockets for live data. It does not, by default, make other outbound network calls – any integration with external systems would happen from within the user’s scripts (inside containers). For instance, if a recipe step calls an API or SSH to a server, that traffic originates from the container, not the LEMC host process.
* **System Resources and Calls:** Under the hood, running a container involves system calls to create processes, configure namespaces, etc., but those are handled by the Docker engine. LEMC’s backend process is mostly an I/O-bound web app orchestrator. It does schedule jobs (which internally might use goroutines/timers via go-quartz) but does not create OS-level cron jobs or similar – scheduling is in-process via the library. The backend might invoke some OS commands indirectly (for example, if using Docker CLI or performing migrations via Goose), but as per the tech stack, most operations use libraries (Docker SDK, Goose for DB migrations) that handle the system interactions. In *Docker Compose* mode, LEMC itself runs in a Docker container (with the socket and data directory mounted), so from the host’s perspective, it’s just another container.
* **External Tools/Systems:** Aside from Docker, DB, and the registry, LEMC doesn’t inherently integrate with other external tools. However, recipes authored by users could invoke anything (Terraform, Ansible, cloud CLIs, etc.) inside their containers. For example, a recipe could run a Terraform container to apply infrastructure changes – the LEMC framework treats it as just another step. The results (terraform plan output, etc.) would be streamed back via LEMC’s channels. In this way, LEMC can function similarly to CI/CD or job-runner systems, but with a focus on interactive, on-demand usage.

In summary, LEMC’s interaction with the host is centered on Docker and file access through controlled channels. It uses Docker to isolate execution, uses the host file system to persist state (DB, env, output files), and uses network connectivity for user access and image distribution. **Host requirements:** To run LEMC, the host needs Docker (with permission for LEMC to access it) and the ability to open the web service port. Because of these interactions, running LEMC typically requires admin/root privileges (for Docker) at least at setup, and it’s geared toward usage in a trusted environment (small team or single user).

## User Configuration and Invocation of LEMC

From a user or developer’s perspective, using LEMC involves a few setup steps followed by execution. The workflow can be divided into: **writing a script and containerizing it**, **registering it as a recipe in LEMC**, and **running it via the LEMC UI**. The following diagram outlines this process end-to-end:

&#x20;*Figure: Workflow for configuring and invoking a LEMC recipe (from development to execution).* First, a developer creates the script or program that they want to automate. This can be any script (shell, Python, Go binary, etc.) that performs the desired task – for example, a script to check server statuses or deploy an application. In the script, the developer can include `print` or `echo` statements with LEMC verbs if they want to produce structured output in the UI (like HTML formatted results). For instance, a Bash script might echo `lemc.html.buffer;<h1>Backup Complete</h1>` to have a heading show up in the web UI, and then `lemc.html.append;` when done with that section of output.

**1. Containerizing the Script:** The developer writes a **Dockerfile** for the script. This Dockerfile will specify a base image (e.g., Python, Alpine Linux, etc.), copy the script into the image, install any dependencies, and set the script as the container’s entrypoint/command. The idea is to ensure that when this Docker image runs, it will execute the script in an environment that has everything it needs. The developer then builds the Docker image locally using `docker build`, tagging it appropriately (e.g., `myuser/lemc-my-script:latest`). If the image is meant to be shared or used on another machine (like a server running LEMC), the developer can **push the image to a registry** (this step is optional if LEMC is running on the same machine where the image is built and you tag it locally). In many cases, a team might use a private registry or Docker Hub to store these images so the LEMC server can pull them. In the Quick Start example, the image is built as `lemc-my-first-recipe:latest` locally, which LEMC can use directly. If it were built elsewhere, they’d push it and then LEMC would pull it by that name.

**2. Defining a Recipe (via LEMC UI):** Once the container image is available, a user (with access to the LEMC web UI) will define a **recipe** that uses it:

* In the LEMC UI, the user navigates to the **Cookbooks** section. They can create a new cookbook or use an existing one to house this recipe (e.g., a cookbook might be a project or category, like “Maintenance Tasks”).
* They choose **“Add New Recipe”**. In the recipe creation form, they provide a name for the recipe and a description. Then they define the first step of the recipe. This involves specifying the **Docker image name** for the step (exactly as tagged, e.g., `lemc-my-first-recipe:latest`). They can also set a timeout for the step’s execution (to auto-stop if it hangs). There’s a field called **“do”** which determines when the step runs; for a single-step recipe or the first step, setting `do: now` means it will run immediately when the recipe is invoked. (If there were multiple steps, subsequent steps could use conditions or delays, but by default they also run immediately sequentially.)
* If the recipe has multiple steps, the user would add additional steps in the UI form, each with its own Docker image (and optionally its own `do` trigger, timeout, etc.). LEMC allows passing in form inputs as environment variables too – the UI might present input fields that map to env vars in the container, but for simplicity, our example doesn’t use that. After filling in the details, the user **saves** the recipe. At this point, the recipe (and its steps configuration) is stored in the LEMC database associated with that cookbook.
* *Under the hood:* Saving a recipe doesn’t immediately run anything; it’s just defining what will happen when the recipe is executed. The LEMC backend now knows which image(s) to use and how to run them when triggered.

**3. Creating an App (Deployment of Cookbook):** LEMC uses a concept of **Apps** to encapsulate cookbooks for execution. An “App” is essentially an instance of a cookbook that can be run. This extra step might seem odd, but it allows one cookbook to be instantiated multiple times (for example, you might have a “Database Maintenance” cookbook, and create two Apps from it – one targeting production DB and one targeting staging DB, each with its own config or scope). In the UI, after defining recipes in a cookbook, the user goes to the **Apps** section:

* They create a new App, give it a name (e.g., “My First Test App”), and select which cookbook it should use. The App will include all recipes from that cookbook. There may be additional settings (like scope: individual vs shared, which determines if the app’s recipes are personal or shared team-wide, or other context), but the main point is linking to the cookbook.
* Once saved, the App is now listed in the UI. Think of an App as a container for running the recipes – it provides an execution context. Each App can have multiple *pages* (sections), corresponding to how recipes might be grouped or displayed. In the default setup, a cookbook might have a default page where all its recipes appear as buttons.

**4. Invoking the Recipe (Run time):** The user is now ready to run their recipe. They navigate in the UI to the App they just created, and within that App, they open the page that contains their new recipe (in many cases, the cookbook’s default page). There they will see the recipe listed (often with a button or action UI element). For example, a recipe named “My Hello World” might appear with a “Run” button. The user clicks the button to execute it. Immediately, the UI will signal that the job is starting (sometimes there’s an indicator or the button changes state), and the backend begins the process described in the Runtime section above. The UI will live-update with the output from the script: in our example, the script prints a hello message and the date, with HTML tags, so the UI shows a formatted greeting and the current date/time. This happens almost instantly after clicking run, thanks to the WebSocket streaming.

* If the image was not already on the host, the user might see a slight delay while “Pulling image…” occurs (LEMC might log that it’s pulling the image). In our quick start, since we built the image locally and gave LEMC the same name, no pull was needed, but LEMC *does* handle image pulls seamlessly via Docker when required.
* After the script finishes (which in this case is quick), the output remains displayed. The user can now interact with that output (if it included a download link or just read the info). They can also run the recipe again or run other recipes. Each execution is typically isolated – running it again will spin up a new container fresh.

**5. Repeating and Managing Recipes:** Users can add more recipes (step 2) to the same cookbook or create new cookbooks and then instantiate them as separate Apps. They can also schedule any recipe to run automatically by configuring a schedule in the UI (if the UI exposes scheduling options per recipe or via the App). The scheduling, as noted, will use the internal scheduler to trigger runs in the background, but users will still see outputs in the App’s interface when they check it. Multiple users can log into LEMC (the admin can create accounts) and use different Apps as permitted. There’s a lightweight permission model, so non-admin users might only see certain Apps or recipes as configured by the admin.

Overall, from configuration to invocation, LEMC’s approach is **developer-friendly**: you write a script as you normally would (maybe adding some `echo` for UI feedback), containerize it, and then just tell LEMC about the container. The system handles the rest – launching the container, streaming output, and providing a web interface for you (or others) to trigger it. This makes it much easier for a small team to automate tasks without setting up heavy CI/CD or bespoke servers. LEMC essentially gives a push-button (or cron) execution environment for any script the team packages, with the big advantage of seeing live results and having a history of runs.

**References:** The above explanations are based on the LEMC documentation and repository, which describe its container-based execution model, real-time UI feedback via special printed commands, environment variable propagation between steps, and usage of Docker and scheduling. The Quick Start guide in the documentation illustrates how a user would create and run a recipe through LEMC’s UI, which aligns with the workflow described above. LEMC’s architecture is designed to be minimal yet powerful, leveraging existing tools (Docker, web tech, databases) to enable developers to automate tasks easily and safely. The diagrams and steps provided give a comprehensive view of how LEMC works internally and how one would interact with it to get things cooking.
